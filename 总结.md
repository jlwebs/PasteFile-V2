# PasteFile 项目使用的 SDK API 总结

## 1. x32dbg/x64dbg Plugin SDK API

### 插件注册与初始化
- `PLUG_INITSTRUCT` - 插件初始化结构体
- `PLUG_SETUPSTRUCT` - 插件设置结构体
- `PLUG_SDKVERSION` - SDK 版本常量
- `pluginHandle` - 插件句柄

### 日志输出
- `_plugin_logputs()` - 输出字符串到日志
- `_plugin_logprintf()` - 格式化输出到日志

### 命令注册
- `_plugin_registercommand()` - 注册插件命令

### 调试器功能
- `DbgValFromString()` - 将字符串转换为调试器地址值
- `DbgGetBpxTypeAt()` - 获取指定地址的断点类型
- `DbgFunctions()->MemPatch()` - 内存补丁函数（写入内存）

### GUI 更新
- `GuiUpdateAllViews()` - 刷新所有调试器视图
- `GuiSelectionGet()` - 获取当前选中的地址范围

### 命令执行
- `DbgCmdExecDirect()` - 直接执行调试器命令（通过宏 `Cmd(x)` 封装）

## 2. Windows API

### 文件操作
- `CreateFileW()` - 打开文件（Unicode 版本）
- `GetFileSize()` - 获取文件大小
- `ReadFile()` - 读取文件内容
- `CloseHandle()` - 关闭文件句柄

### 字符串转换
- `MultiByteToWideChar()` - UTF-8 转 UTF-16 编码转换

### DLL 入口
- `DllMain()` - DLL 主入口函数

## 3. 引用但未实际使用的 SDK

虽然在 `pluginmain.h` 中包含了以下 SDK 头文件，但在实际代码中**并未调用**这些库的 API：

- **TitanEngine** - 未使用
- **Capstone** - 未使用
- **XEDParse** - 未使用
- **Jansson** - 未使用
- **LZ4** - 未使用
- **YARA** - 未使用
- **DeviceNameResolver** - 未使用

这些库仅作为 x32dbg 插件 SDK 的标准模板引入，但本插件的核心功能（文件读取与内存补丁）并不依赖它们。

---

## 4. 核心实现流程:如何实现内存补丁

### 整体架构
```
用户命令 → 参数解析 → 文件读取 → 地址计算 → 内存写入 → 界面刷新
```

### 详细步骤

#### Step 1: 命令注册
```cpp
// 在插件初始化时注册命令
_plugin_registercommand(pluginHandle, PLUGIN_NAME, cbCommand, false);
```
- **作用**: 将 `PasteFile` 命令绑定到回调函数 `cbCommand`
- **参数**: 插件句柄、命令名、回调函数、是否为调试命令

#### Step 2: 参数解析
```cpp
// 支持多种格式:
// 1. PasteFile file.bin,401000
// 2. PasteFile file.bin 401000
// 3. PasteFile file.bin,401000,402000 (带结束地址)

char* filename = argv[1];
duint start = DbgValFromString(addrStr);  // 解析起始地址
duint endLimit = DbgValFromString(endAddrStr);  // 解析结束地址(可选)
```
- **DbgValFromString()**: 将字符串(如 "401000" 或 "eip+100")转换为实际内存地址

#### Step 3: 文件读取
```cpp
// 使用 Windows API 读取二进制文件
HANDLE hFile = CreateFileW(Utf8ToUtf16(fileName).c_str(), GENERIC_READ, ...);
unsigned int filesize = GetFileSize(hFile, nullptr);
std::vector<uint8_t> content(filesize);
ReadFile(hFile, content.data(), filesize, &read, nullptr);
CloseHandle(hFile);
```
- **关键点**: 使用 UTF-8 → UTF-16 转换支持中文路径

#### Step 4: 获取目标地址
```cpp
// 如果用户未指定地址,使用当前 Dump 窗口选中的地址
if (!addrStr) {
    SELECTIONDATA sel;
    GuiSelectionGet(GUI_DUMP, &sel);
    start = sel.start;
}
```
- **GuiSelectionGet()**: 获取用户在 Dump 视图中选中的内存范围

#### Step 5: 边界检查与截断
```cpp
// 如果指定了结束地址,防止越界写入
if (endLimit != (duint)-1 && (start + size) > endLimit) {
    duint newSize = endLimit - start;
    truncatedBytes = size - newSize;
    size = newSize;  // 截断数据
}
```
- **安全机制**: 避免写入超出指定范围的内存

#### Step 6: 核心补丁操作 ⭐
```cpp
// 调用 x32dbg 的内存补丁 API
if (DbgFunctions()->MemPatch(start, data.data(), size)) {
    _plugin_logprintf("[PasteFile] Patch successful!\n");
} else {
    _plugin_logputs("[PasteFile] Patch failed!");
}
```
- **DbgFunctions()->MemPatch()**: 
  - **参数1**: 目标内存地址 (duint)
  - **参数2**: 数据缓冲区指针 (const void*)
  - **参数3**: 数据大小 (duint)
  - **返回值**: 成功返回 true,失败返回 false
  - **内部机制**: 
    - 自动处理内存保护属性(VirtualProtect)
    - 写入数据到目标进程内存
    - 记录补丁历史(可通过 x32dbg 的 Patches 窗口查看)

#### Step 7: 刷新界面
```cpp
GuiUpdateAllViews();
```
- **作用**: 通知 x32dbg 刷新所有视图(反汇编、Dump、堆栈等)
- **必要性**: 确保用户立即看到内存变化

### 关键 API 详解

#### `DbgFunctions()->MemPatch()`
这是整个插件的核心 API,其内部实现包括:

1. **权限提升**: 
   ```cpp
   VirtualProtectEx(hProcess, addr, size, PAGE_EXECUTE_READWRITE, &oldProtect);
   ```

2. **内存写入**:
   ```cpp
   WriteProcessMemory(hProcess, addr, data, size, &written);
   ```

3. **恢复权限**:
   ```cpp
   VirtualProtectEx(hProcess, addr, size, oldProtect, &temp);
   ```

4. **补丁记录**: 将修改记录到 x32dbg 的补丁管理系统

#### `DbgValFromString()`
支持多种地址表达式:
- 十六进制: `"401000"`, `"0x401000"`
- 寄存器: `"eip"`, `"esp+10"`
- 符号: `"main"`, `"kernel32.CreateFileW"`
- 表达式: `"[eax+4]"`, `"eip+100"`

### 使用示例

```cpp
// 示例 1: 将 shellcode.bin 写入当前选中地址
PasteFile C:\shellcode.bin

// 示例 2: 写入到指定地址
PasteFile C:\patch.bin,401000

// 示例 3: 限制写入范围(只写 401000-402000)
PasteFile C:\large.bin,401000,402000

// 示例 4: 使用表达式
PasteFile C:\data.bin,eip+100
```

### 错误处理

```cpp
// 1. 文件不存在
if (!ReadAllData(filename, data)) {
    _plugin_logprintf("[PasteFile] Failed to read file: %s\n", filename);
    return false;
}

// 2. 地址无效
if (DbgGetBpxTypeAt(start) == bp_none && !DbgMemIsValidReadPtr(start)) {
    _plugin_logputs("[PasteFile] Invalid address!\n");
}

// 3. 内存写入失败
if (!DbgFunctions()->MemPatch(...)) {
    _plugin_logputs("[PasteFile] Patch failed! (Memory protection or invalid range)\n");
}
```

### 最佳实践

1. **始终指定结束地址**: 避免意外覆盖关键内存区域
2. **使用绝对路径**: 防止文件路径解析错误
3. **检查日志输出**: 通过 `_plugin_logprintf` 查看详细执行信息
4. **备份原始数据**: 在补丁前使用 x32dbg 的 "Copy to executable" 功能备份
